'use strict'; // JS: ES5

// ******************************
//
//
// HTML DEFINITION FILE
//
//
// ******************************

// ******************************
// Requires:
// ******************************

var grammar = require('./_core');

// ******************************
// Definition:
// ******************************

module.exports = grammar.export_grammar({
  START: { OPERATOR: '&&', SEGMENTS: ['STATEMENT+'] },
  STATEMENT: { OPERATOR: '||', SEGMENTS: ['VAL__SINGLE_LINE_COMMENT', 'VAL__IMPORT_STATEMENT', 'COMPONENT_DECLARATION', 'CLASS_DECLARATION'] },

  // COMPONENT DECLARATION
  COMPONENT_DECLARATION: { OPERATOR: '&&', SEGMENTS: ['VAL__COMPONENT_DECLARATION_KEY', 'VAL__PAREN_L', 'COMPONENT_DECLARATION_CONTENTS', 'VAL__PAREN_R'] },
  COMPONENT_DECLARATION_CONTENTS: { OPERATOR: '&&', SEGMENTS: ['VAL__CURLY_L', 'COMPONENT_DECLARATION_ENTRY', 'COMMA_COMPONENT_DECLARATION_ENTRY*', 'VAL__COMMA?', 'VAL__CURLY_R'] },
  COMPONENT_DECLARATION_ENTRY: { OPERATOR: '&&', SEGMENTS: ['VAL__LETTERS', 'VAL__COLON', 'COMPONENT_DECLARATION_ENTRY_VALUE'] },
  COMMA_COMPONENT_DECLARATION_ENTRY: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'COMPONENT_DECLARATION_ENTRY'] },
  COMPONENT_DECLARATION_ENTRY_VALUE: { OPERATOR: '||', SEGMENTS: ['STRING_VALUE', 'SQUARE_BRACKETS_VALUE', 'CLASS_VARIABLE_NAME'] },

  // CLASS DECLARATION:
  CLASS_DECLARATION: { OPERATOR: '&&', SEGMENTS: ['TOKEN__EXPORT?', 'TOKEN__CLASS', 'VAL__CLASS_NAME', 'CLASS_EXTENDS?', 'CLASS_IMPLEMENTS?', 'CLASS_CONTENTS'] },
  CLASS_EXTENDS: { OPERATOR: '&&', SEGMENTS: ['TOKEN__EXTENDS', 'VAL__CLASS_NAME'] },
  CLASS_IMPLEMENTS: { OPERATOR: '&&', SEGMENTS: ['TOKEN__IMPLEMENTS', 'CLASS_NAMES'] },
  CLASS_NAMES: { OPERATOR: '&&', SEGMENTS: ['VAL__CLASS_NAME', 'COMMA_CLASS_NAME*'] },
  COMMA_CLASS_NAME: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'VAL__CLASS_NAME'] },
  CLASS_CONTENTS: { OPERATOR: '&&', SEGMENTS: ['VAL__CURLY_L', 'CLASS_CONTENT*', 'VAL__CURLY_R'] },
  CLASS_CONTENT: { OPERATOR: '||', SEGMENTS: ['CLASS_ELEMENT_DECLARATION', 'CONSTRUCTOR_DECLARATION', 'VAL__SINGLE_LINE_COMMENT'] },

  // CLASS VALUES
  CLASS_ELEMENT_DECLARATION: { OPERATOR: '&&', SEGMENTS: ['CLASS_ELEMENT_DECLARATION_TYPE', 'VAL__SEMI?'] },
  CLASS_ELEMENT_DECLARATION_TYPE: { OPERATOR: '||', SEGMENTS: ['CLASS_BOUND_DECLARATION', 'CLASS_UNBOUND_DECLARATION'] },
  CLASS_BOUND_DECLARATION: { OPERATOR: '&&', SEGMENTS: ['CLASS_BINDING', 'ACCESS_MODIFIER?', 'ACCESSOR?', 'CLASS_BINDING_VALUE'] },
  CLASS_UNBOUND_DECLARATION: { OPERATOR: '&&', SEGMENTS: ['ACCESS_MODIFIER?', 'CLASS_DECLARATION_TYPE'] },
  CLASS_DECLARATION_TYPE: { OPERATOR: '||', SEGMENTS: ['CLASS_ACCESSOR_DECLARATION', 'CLASS_NAMED_DECLARATION'] },
  CLASS_BINDING: { OPERATOR: '&&', SEGMENTS: ['CLASS_BINDING_TOKEN', 'VAL__PAREN_L', 'CLASS_BINDING_TOKEN_CONTENTS?', 'VAL__PAREN_R'] },
  CLASS_BINDING_TOKEN: { OPERATOR: '||', SEGMENTS: ['TOKEN__INPUT', 'TOKEN__OUTPUT', 'TOKEN__HOST_BINDING', 'TOKEN__VIEW_CHILD'] },
  CLASS_BINDING_TOKEN_CONTENTS: { OPERATOR: '&&', SEGMENTS: ['STRING_VALUE'] },

  CLASS_BINDING_VALUE: { OPERATOR: '||', SEGMENTS: ['VARIABLE_VALUE', 'CLASS_BINDING_VALUE_NAMED', 'CLASS_ACCESSOR_DECLARATION'] },
  CLASS_BINDING_VALUE_NAMED: { OPERATOR: '&&', SEGMENTS: ['VAL__LETTERS', 'CLASS_BINDING_VALUE_NAMED_TYPE'] },
  CLASS_BINDING_VALUE_NAMED_TYPE: { OPERATOR: '||', SEGMENTS: ['CLASS_BINDING_ASSIGNMENT', 'CLASS_NAMED_DECLARATION_TYPE'] },
  CLASS_BINDING_ASSIGNMENT: { OPERATOR: '&&', SEGMENTS: ['VAL__EQ', 'VARIABLE_VALUE'] },

  CLASS_ACCESSOR_DECLARATION: { OPERATOR: '&&', SEGMENTS: ['ACCESSOR', 'VAL__LETTERS', 'FUNCTION_CALL', 'BLOCK'] },
  CLASS_NAMED_DECLARATION: { OPERATOR: '&&', SEGMENTS: ['VAL__LETTERS', 'CLASS_NAMED_DECLARATION_TYPE'] },
  CLASS_NAMED_DECLARATION_TYPE: { OPERATOR: '||', SEGMENTS: ['CLASS_NAMED_FUNCTION_DECLARATION', 'CLASS_NAMED_FIELD_DECLARATION', 'CLASS_NAMED_FIELD_EVENT_DECLARATION'] },

  CLASS_NAMED_FUNCTION_DECLARATION: { OPERATOR: '&&', SEGMENTS: ['FUNCTION', 'FUNCTION_RETURN_TYPE?', 'BLOCK'] },
  CLASS_NAMED_FIELD_DECLARATION: { OPERATOR: '&&', SEGMENTS: ['VAL__COLON', 'VAL__LETTERS', 'FIELD_DECLARATION_ASSIGNMENT?'] },
  CLASS_NAMED_FIELD_EVENT_DECLARATION: { OPERATOR: '&&', SEGMENTS: ['VAL__DOLLAR', 'VAL__COLON', 'CLASS_TYPE', 'VAL__EQ', 'VARIABLE_VALUE'] },

  CLASS_DOT_NAMESPACE: { OPERATOR: '&&', SEGMENTS: ['VAL__LETTERS', 'VAL__DOT'] },
  CLASS_VARIABLE_NAME: { OPERATOR: '&&', SEGMENTS: ['CLASS_DOT_NAMESPACE*', 'VAL__VARIABLE_NAME'] },

  CLASS_VALUE: { OPERATOR: '&&', SEGMENTS: ['CLASS_DOT_NAMESPACE*', 'CLASS_VALUE_TYPES'] },
  CLASS_VALUE_TYPES: { OPERATOR: '||', SEGMENTS: ['CLASS_FUNCTION_CALL', 'VAL__VARIABLE_NAME'] },

  CLASS_BLOCK_VALUE: { OPERATOR: '&&', SEGMENTS: ['CLASS_DOT_NAMESPACE*', 'CLASS_BLOCK_VALUE_CALL', 'VAL__SEMI'] },
  CLASS_BLOCK_VALUE_CALL: { OPERATOR: '||', SEGMENTS: ['CLASS_FUNCTION_CALL', 'VARIABLE_ASSIGNMENT'] },
  CLASS_BLOCK_RETURN_STATEMENT: { OPERATOR: '&&', SEGMENTS: ['TOKEN__RETURN', 'CLASS_VALUE', 'VAL__SEMI'] },
  CLASS_FUNCTION_CALL: { OPERATOR: '&&', SEGMENTS: ['VAL__LETTERS', 'FUNCTION_CALL'] },

  // FIELD DECLARATION:
  FIELD_DECLARATION_ASSIGNMENT: { OPERATOR: '&&', SEGMENTS: ['VAL__EQ', 'VARIABLE_VALUE'] },

  // FUNCTION DECLARATION:
  ACCESS_MODIFIER: { OPERATOR: '||', SEGMENTS: ['TOKEN__PUBLIC', 'TOKEN__PRIVATE', 'TOKEN__PROTECTED'] },
  ACCESSOR: { OPERATOR: '||', SEGMENTS: ['TOKEN__SET', 'TOKEN__GET'] },
  FUNCTION: { OPERATOR: '&&', SEGMENTS: ['VAL__PAREN_L', 'FUNCTION_PARAMS?', 'VAL__PAREN_R'] },
  FUNCTION_RETURN_TYPE: { OPERATOR: '&&', SEGMENTS: ['VAL__COLON', 'VAL__LETTERS'] },
  FUNCTION_PARAMS: { OPERATOR: '&&', SEGMENTS: ['FUNCTION_PARAM', 'COMMA_FUNCTION_PARAM*'] },
  FUNCTION_PARAM: { OPERATOR: '&&', SEGMENTS: ['VAL__LETTERS', 'VAL__COLON', 'VAL__LETTERS'] },
  COMMA_FUNCTION_PARAM: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'FUNCTION_PARAM*'] },

  // CONSTRUCTOR DECLARATION:
  CONSTRUCTOR_DECLARATION: { OPERATOR: '&&', SEGMENTS: ['TOKEN__CONSTRUCTOR', 'CONSTRUCTOR_PARAMS', 'BLOCK'] },
  CONSTRUCTOR_PARAMS: { OPERATOR: '&&', SEGMENTS: ['VAL__PAREN_L', 'CONSTRUCTOR_PARAM', 'COMMA_CONSTRUCTOR_PARAM*', 'VAL__PAREN_R'] },
  CONSTRUCTOR_PARAM: { OPERATOR: '&&', SEGMENTS: ['ACCESS_MODIFIER?', 'VAL__LETTERS', 'VAL__COLON', 'VAL__LETTERS'] },
  COMMA_CONSTRUCTOR_PARAM: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'CONSTRUCTOR_PARAM*'] },

  // FUNCTION CALL
  FUNCTION_CALL: { OPERATOR: '&&', SEGMENTS: ['VAL__PAREN_L', 'FUNCTION_CALL_ARGS?', 'VAL__PAREN_R'] },
  FUNCTION_CALL_ARGS: { OPERATOR: '&&', SEGMENTS: ['FUNCTION_CALL_ARG', 'COMMA_FUNCTION_CALL_ARG*'] },
  FUNCTION_CALL_ARG: { OPERATOR: '||', SEGMENTS: ['VARIABLE_VALUE', 'CLASS_VARIABLE_NAME'] },
  COMMA_FUNCTION_CALL_ARG: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'FUNCTION_CALL_ARG*'] },

  // VARIABLE ASSIGNMENT
  VARIABLE_ASSIGNMENT: { OPERATOR: '&&', SEGMENTS: ['VAL__VARIABLE_NAME', 'VAL__EQ', 'VARIABLE_ASSIGNMENT_VALUE'] },
  VARIABLE_ASSIGNMENT_VALUE: { OPERATOR: '||', SEGMENTS: ['STRUCT_VALUE', 'CONDITION'] },

  // CONDITIONAL STATEMENT
  CONDITIONAL_STATEMENT: { OPERATOR: '&&', SEGMENTS: ['CONDITIONAL_OPERATOR', 'CONDITIONAL_PARAMS', 'BLOCK'] },
  CONDITIONAL_OPERATOR: { OPERATOR: '||', SEGMENTS: ['TOKEN__IF', 'ELSE_IF', 'TOKEN__WHILE'] },
  CONDITIONAL_PARAMS: { OPERATOR: '&&', SEGMENTS: ['VAL__PAREN_L', 'CONDITION', 'VAL__PAREN_R'] },

  // STRUCT VALUE
  STRUCT_VALUE: { OPERATOR: '&&', SEGMENTS: ['VAL__CURLY_L', 'STRUCT_CONTENTS', 'VAL__CURLY_R'] },
  STRUCT_CONTENTS: { OPERATOR: '&&', SEGMENTS: ['STRUCT_CONTENT', 'COMMA_STRUCT_CONTENT*'] },
  COMMA_STRUCT_CONTENT: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'STRUCT_CONTENT'] },
  STRUCT_CONTENT: { OPERATOR: '&&', SEGMENTS: ['VAL__LETTERS', 'VAL__COLON', 'VAL__LETTERS'] },

  // CONDITION
  CONDITION: { OPERATOR: '||', SEGMENTS: ['ODD_EXPRESSION_CONDITION', 'EXPRESSION_CONDITION'] },
  ODD_EXPRESSION_CONDITION: { OPERATOR: '&&', SEGMENTS: ['VAL__EXCLAM', 'EXPRESSION'] },

  EXPRESSION_CONDITION: { OPERATOR: '&&', SEGMENTS: ['EXPRESSION', 'COMPARE_EXPRESSION?'] },
  COMPARE_EXPRESSION: { OPERATOR: '&&', SEGMENTS: ['COMPARE_OPERATOR', 'EXPRESSION'] },

  EXPRESSION: { OPERATOR: '&&', SEGMENTS: ['MATH_OPERATOR?', 'TERM', 'OPERATOR_TERM*'] },
  OPERATOR_TERM: { OPERATOR: '&&', SEGMENTS: ['MATH_OPERATOR', 'TERM'] },

  TERM: { OPERATOR: '&&', SEGMENTS: ['FACTOR', 'COMBINE_FACTOR*'] },
  COMBINE_FACTOR: { OPERATOR: '&&', SEGMENTS: ['COMBINE_OPERATOR', 'FACTOR'] },

  FACTOR: { OPERATOR: '||', SEGMENTS: ['VARIABLE_VALUE', 'CLASS_VALUE', 'EXPRESSION_IN_PAREN'] },
  EXPRESSION_IN_PAREN: { OPERATOR: '&&', SEGMENTS: ['VAL__PAREN_L', 'EXPRESSION', 'VAL__PAREN_R'] },

  COMPARE_OPERATOR: { OPERATOR: '||', SEGMENTS: ['VAL__EQEQ', 'VAL__LTEQ', 'VAL__LT', 'VAL__GTEQ', 'VAL__GT', 'VAL__NOTEQ'] },
  COMBINE_OPERATOR: { OPERATOR: '||', SEGMENTS: ['VAL__AND', 'VAL__OR'] },
  MATH_OPERATOR: { OPERATOR: '||', SEGMENTS: ['VAL__PLUS', 'VAL__MINUS', 'VAL__TIMES', 'VAL__DIVIDE'] },

  // CORE NODES
  ELSE_IF: { OPERATOR: '&&', SEGMENTS: ['TOKEN__ELSE', 'TOKEN__IF'] },
  BLOCK: { OPERATOR: '&&', SEGMENTS: ['VAL__CURLY_L', 'BLOCK_CONTENT*', 'VAL__CURLY_R'] },
  BLOCK_CONTENT: { OPERATOR: '||', SEGMENTS: ['CLASS_BLOCK_VALUE', 'CLASS_BLOCK_RETURN_STATEMENT', 'CONDITIONAL_STATEMENT'] },
  SQUARE_BRACKETS_VALUE: { OPERATOR: '&&', SEGMENTS: ['VAL__SQBRAC_L', 'SQUARE_BRACKETS_VALUE_CONTENT', 'VAL__SQBRAC_R'] },
  SQUARE_BRACKETS_VALUE_CONTENT: { OPERATOR: '||', SEGMENTS: ['VARIABLE_VALUE', 'VAL__VARIABLE_NAME'] },
  VARIABLE_VALUE: { OPERATOR: '||', SEGMENTS: ['VAL__NUMERIC', 'BOOLEAN_VALUE', 'STRING_VALUE', 'NEW_CLASS_TYPE'] },
  STRING_VALUE: { OPERATOR: '||', SEGMENTS: ['VAL__DQUOTED_STRING', 'VAL__SQUOTED_STRING'] },
  BOOLEAN_VALUE: { OPERATOR: '||', SEGMENTS: ['VAL__TRUE', 'VAL__FALSE'] },
  NEW_CLASS_TYPE: { OPERATOR: '&&', SEGMENTS: ['TOKEN__NEW', 'CLASS_TYPE', 'FUNCTION_CALL'] },
  CLASS_TYPE: { OPERATOR: '&&', SEGMENTS: ['VAL__LETTERS', 'VAL__ANBRAC_L', 'VAL__LETTERS', 'VAL__ANBRAC_R'] },

  // VALS:
  VAL__CLASS_NAME: { OPERATOR: '==', VALUE: '[a-zA-Z<>]+' },
  VAL__COMPONENT_DECLARATION_KEY: { OPERATOR: '==', VALUE: '@[a-zA-Z]+' },
  VAL__DQUOTED_STRING: { OPERATOR: '==', VALUE: '"[^"]*?"' },
  VAL__IMPORT_STATEMENT: { OPERATOR: '==', VALUE: 'import [^;]*;' },
  VAL__LETTERS: { OPERATOR: '==', VALUE: '[a-zA-Z]+' },
  VAL__NUMERIC: { OPERATOR: '==', VALUE: '-?[0-9]+(:?.[0-9]+)?' },
  VAL__SINGLE_LINE_COMMENT: { OPERATOR: '==', VALUE: '\\/\\/[^\\n\\r]*' },
  VAL__SQUOTED_STRING: { OPERATOR: '==', VALUE: '\'[^\']*?\'' },
  VAL__VARIABLE_NAME: { OPERATOR: '==', VALUE: '\\$?[a-zA-Z0-9_]+' },

  // TOKENS
  TOKEN__CLASS: { OPERATOR: '==', VALUE: 'class' },
  TOKEN__CONSTRUCTOR: { OPERATOR: '==', VALUE: 'constructor' },
  TOKEN__ELSE: { OPERATOR: '==', VALUE: 'else' },
  TOKEN__EXPORT: { OPERATOR: '==', VALUE: 'export' },
  TOKEN__EXTENDS: { OPERATOR: '==', VALUE: 'extends' },
  TOKEN__GET: { OPERATOR: '==', VALUE: 'get' },
  TOKEN__HOST_BINDING: { OPERATOR: '==', VALUE: '@HostBinding' },
  TOKEN__IF: { OPERATOR: '==', VALUE: 'if' },
  TOKEN__IMPLEMENTS: { OPERATOR: '==', VALUE: 'implements' },
  TOKEN__INPUT: { OPERATOR: '==', VALUE: '@Input' },
  TOKEN__NEW: { OPERATOR: '==', VALUE: 'new' },
  TOKEN__OUTPUT: { OPERATOR: '==', VALUE: '@Output' },
  TOKEN__PRIVATE: { OPERATOR: '==', VALUE: 'private' },
  TOKEN__PROTECTED: { OPERATOR: '==', VALUE: 'protected' },
  TOKEN__PUBLIC: { OPERATOR: '==', VALUE: 'public' },
  TOKEN__RETURN: { OPERATOR: '==', VALUE: 'return' },
  TOKEN__SET: { OPERATOR: '==', VALUE: 'set' },
  TOKEN__VIEW_CHILD: { OPERATOR: '==', VALUE: '@ViewChild' },
  TOKEN__WHILE: { OPERATOR: '==', VALUE: 'while' },
}, [
  require('./base')
]);

// ******************************