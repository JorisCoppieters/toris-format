'use strict'; // JS: ES5

// ******************************
//
//
// SCSS DEFINITION FILE
//
//
// ******************************

// ******************************
// Requires:
// ******************************

var grammar = require('./_core');

// ******************************
// Definition:
// ******************************

module.exports = grammar.export_grammar({
    START: { OPERATOR: '||', SEGMENTS: ['stylesheet'] },
    // SCSS_SEGMENTS: { OPERATOR: '||', SEGMENTS: ['stylesheet'] },
    stylesheet: { OPERATOR: '&&', SEGMENTS: ['statement*'] },
    statement: { OPERATOR: '||', SEGMENTS: ['COMMENT', 'SL_COMMENT', 'importDeclaration', 'includeDeclaration', 'fontFaceDeclaration', 'mediaDeclaration', 'DECLARATION_KEYFRAMES', 'pageDeclaration', 'extendDeclaration', 'ruleset', 'mixinDeclaration', 'functionDeclaration', 'variableDeclaration', 'ifDeclaration', 'forDeclaration', 'whileDeclaration', 'eachDeclaration', 'nested'] },
    params: { OPERATOR: '&&', SEGMENTS: ['param', 'paramMore*', 'ELLIPSIS?'] },
    paramMore: { OPERATOR: '&&', SEGMENTS: ['COMMA', 'param*', 'ELLIPSIS?'] },
    param: { OPERATOR: '&&', SEGMENTS: ['variableName', 'paramOptionalValue?'] },
    variableName: { OPERATOR: '&&', SEGMENTS: ['DOLLAR', 'IDENTIFIER?'] },
    paramOptionalValue: { OPERATOR: '&&', SEGMENTS: ['COLON', 'expression'] },
    paramsInParen: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'params?', 'RPAREN'] },
    valuesInParen: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'values?', 'RPAREN'] },
    mixinDeclaration: { OPERATOR: '&&', SEGMENTS: ['MIXIN', 'IDENTIFIER', 'paramsInParen?', 'block'] },
    pageDeclaration: { OPERATOR: '&&', SEGMENTS: ['PAGE', 'block'] },
    extendDeclaration: { OPERATOR: '&&', SEGMENTS: ['EXTEND', 'percIdentifier', 'SEMI?'] },
    includeDeclaration: { OPERATOR: '&&', SEGMENTS: ['INCLUDE', 'IDENTIFIER', 'includeDeclarationTermination'] },
    includeDeclarationTermination: { OPERATOR: '||', SEGMENTS: ['SEMI+', 'valuesInParenSemiBlock'] },
    fontFaceDeclaration: { OPERATOR: '&&', SEGMENTS: ['FONT_FACE', 'fontFaceDeclarationStart', 'fontFaceDeclarationValues', 'fontFaceDeclarationEnd'] },
    fontFaceDeclarationStart: { OPERATOR: '&&', SEGMENTS: ['BLOCKSTART'] },
    fontFaceDeclarationValues: { OPERATOR: '&&', SEGMENTS: ['blockProperty*'] },
    fontFaceDeclarationEnd: { OPERATOR: '&&', SEGMENTS: ['BLOCKEND'] },

    mediaDeclaration: { OPERATOR: '&&', SEGMENTS: ['MEDIA', 'mediaDeclarationContent', 'commaMediaDeclarationContent*', 'block'] },
    commaMediaDeclarationContent: { OPERATOR: '&&', SEGMENTS: ['COMMA', 'mediaDeclarationContent'] },

    mediaDeclarationContent: { OPERATOR: '||', SEGMENTS: ['mediaDeclarationPart', 'mediaDeclarationPartInParen'] },
    mediaDeclarationPartInParen: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'mediaDeclarationContent', 'RPAREN', 'mediaCombineDeclarationPart*'] },

    mediaDeclarationPart: { OPERATOR: '&&', SEGMENTS: ['mediaDeclarationIdentifier', 'mediaCombineDeclarationPart*'] },
    mediaCombineDeclarationPart: { OPERATOR: '&&', SEGMENTS: ['TYPE_COMBINE_OPERATORS', 'mediaDeclarationContent'] },

    mediaDeclarationIdentifier: { OPERATOR: '||', SEGMENTS: ['SCREEN', 'property'] },

    // mediaDeclarationTermination: { OPERATOR: '||', SEGMENTS: ['SEMI+', 'valuesInParenSemiBlock'] },
    valuesInParenSemi: { OPERATOR: '&&', SEGMENTS: ['valuesInParen', 'SEMI?'] },
    valuesInParenSemiBlock: { OPERATOR: '&&', SEGMENTS: ['valuesInParenSemi?', 'block?'] },
    functionDeclaration: { OPERATOR: '&&', SEGMENTS: ['FUNCTION', 'IDENTIFIER', 'paramsInParen', 'BLOCKSTART', 'functionBody?', 'BLOCKEND'] },
    functionBody: { OPERATOR: '&&', SEGMENTS: ['functionStatement*', 'functionReturn'] },
    functionReturn: { OPERATOR: '&&', SEGMENTS: ['RETURN', 'commandStatement', 'SEMI+'] },
    functionStatement: { OPERATOR: '&&', SEGMENTS: ['commandStatement', 'semiOrStatement'] },
    semiOrStatement: { OPERATOR: '||', SEGMENTS: ['SEMI+', 'statement'] },
    commandStatement: { OPERATOR: '&&', SEGMENTS: ['expressionOrCommandStatement', 'mathStatement?'] },
    expressionOrCommandStatement: { OPERATOR: '||', SEGMENTS: ['expressions', 'commaCommandStatement'] },
    expressions: { OPERATOR: '||', SEGMENTS: ['expressions3Plus', 'expressions3Less'] },
    expressions3Plus: { OPERATOR: '&&', SEGMENTS: ['expression+', 'commaExpression', 'commaExpression+', 'extraComma?'] },
    expressions3Less: { OPERATOR: '&&', SEGMENTS: ['expression+', 'commaExpression*', 'extraComma?'] },
    expressionsInParens: { OPERATOR: '||', SEGMENTS: ['expressions3PlusInParens', 'expressions3LessInParens'] },
    expressions3PlusInParens: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'expressions3Plus', 'RPAREN'] },
    expressions3LessInParens: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'expressions3Less', 'RPAREN'] },
    commaExpression: { OPERATOR: '&&', SEGMENTS: ['COMMA', 'expression+'] },
    // commandStatementInParens: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'commandStatement', 'RPAREN'] },
    mathCharacter: { OPERATOR: '||', SEGMENTS: ['TIMES', 'PLUS', 'DIV', 'MINUS', 'PERC'] },
    mathStatement: { OPERATOR: '&&', SEGMENTS: ['mathCharacter', 'commandStatement'] },
    expression: { OPERATOR: '||', SEGMENTS: ['Url', 'functionCall', 'expressionsInParens', 'mapExpression', 'SL_COMMENT', 'COMMENT', 'mathCharacter', 'MEASUREMENT', 'NUMBER', 'identifier', 'RGB', 'COLOR', 'STRINGLITERAL', 'NULL', 'param'] },
    // IdentifierOrMathCharacter: { OPERATOR: '||', SEGMENTS: ['IDENTIFIER', 'PERC'] },
    mapExpression: { OPERATOR: '&&', SEGMENTS: ['mapExpressionStart', 'mapEntry', 'commaMapEntry*', 'extraComma?', 'comment?', 'mapExpressionEnd'] },
    mapExpressionStart: { OPERATOR: '&&', SEGMENTS: ['LPAREN'] },
    mapExpressionEnd: { OPERATOR: '&&', SEGMENTS: ['RPAREN'] },
    mapEntry: { OPERATOR: '&&', SEGMENTS: ['comment?', 'mapEntryKeyValue', 'comment?'] },
    mapEntryKeyValue: { OPERATOR: '&&', SEGMENTS: ['mapEntryKey', 'COLON', 'mapEntryValues'] },
    mapEntryKey: { OPERATOR: '||', SEGMENTS: ['NUMBER', 'STRINGLITERAL', 'IDENTIFIER'] },
    mapEntryValues: { OPERATOR: '&&', SEGMENTS: ['mathCharacter?', 'expression'] },
    extraComma: { OPERATOR: '&&', SEGMENTS: ['COMMA'] },
    commaMapEntry: { OPERATOR: '&&', SEGMENTS: ['COMMA', 'mapEntry'] },
    RGB: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'RGB_VAL', 'COMMA_RGB_VAL*', 'RPAREN'] },
    COMMA_RGB_VAL: { OPERATOR: '&&', SEGMENTS: ['COMMA', 'RGB_VAL'] },
    RGB_VAL: { OPERATOR: '||', SEGMENTS: ['RGB_NUMERIC_VAL', 'variableName'] },
    ifDeclaration: { OPERATOR: '&&', SEGMENTS: ['AT_IF', 'TYPE_CONDITIONS', 'block', 'elseIfStatement*', 'elseStatement?'] },
    elseIfStatement: { OPERATOR: '&&', SEGMENTS: ['AT_ELSE', 'IF', 'TYPE_CONDITIONS', 'block'] },
    elseStatement: { OPERATOR: '&&', SEGMENTS: ['AT_ELSE', 'block'] },

    variableDeclaration: { OPERATOR: '&&', SEGMENTS: ['variableDeclarationKey', 'COLON', 'variableDeclarationValues', 'POUND_DEFAULT?', 'SEMI+'] },
    variableDeclarationKey: { OPERATOR: '||', SEGMENTS: ['STRINGLITERAL', 'variableName'] },
    variableDeclarationValues: { OPERATOR: '&&', SEGMENTS: ['values'] },
    commaVariableName: { OPERATOR: '&&', SEGMENTS: ['COMMA', 'variableName'] },
    commaIdentifier: { OPERATOR: '&&', SEGMENTS: ['COMMA', 'IDENTIFIER'] },
    colonValues: { OPERATOR: '&&', SEGMENTS: ['COLON', 'values'] },
    forDeclaration: { OPERATOR: '&&', SEGMENTS: ['AT_FOR', 'variableName', 'FROM', 'fromNumber', 'THROUGH', 'through', 'block'] },
    fromNumber: { OPERATOR: '&&', SEGMENTS: ['NUMBER'] },
    through: { OPERATOR: '||', SEGMENTS: ['NUMBER', 'functionCall', 'variableName'] },
    whileDeclaration: { OPERATOR: '&&', SEGMENTS: ['AT_WHILE', 'TYPE_CONDITIONS', 'block'] },
    eachDeclaration: { OPERATOR: '&&', SEGMENTS: ['AT_EACH', 'variableName', 'commaVariableName*', 'IN', 'eachValueList', 'block'] },
    eachValueList: { OPERATOR: '&&', SEGMENTS: ['eachValueListEntry', 'commaEachValueListEntry*'] },
    eachValueListEntry: { OPERATOR: '||', SEGMENTS: ['eachValueListInParen', 'functionCall', 'IDENTIFIER', 'identifierValue', 'variableName'] },
    commaEachValueListEntry: { OPERATOR: '&&', SEGMENTS: ['COMMA', 'eachValueListEntry'] },
    eachValueListInParen: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'eachValueList', 'RPAREN'] },
    identifierValue: { OPERATOR: '&&', SEGMENTS: ['identifier', 'colonValues?'] },
    importDeclaration: { OPERATOR: '&&', SEGMENTS: ['IMPORT', 'referenceUrl', 'commaReferenceUrl*', 'mediaTypes?', 'SEMI+'] },
    referenceUrl: { OPERATOR: '||', SEGMENTS: ['STRINGLITERAL', 'Url'] },
    commaReferenceUrl: { OPERATOR: '&&', SEGMENTS: ['COMMA', 'referenceUrl'] },
    mediaTypes: { OPERATOR: '&&', SEGMENTS: ['IDENTIFIER', 'commaIdentifier*'] },
    nested: { OPERATOR: '&&', SEGMENTS: ['AT', 'AND?', 'IDENTIFIER+', 'pseudo*', 'selectors', 'BLOCKSTART', 'stylesheet', 'BLOCKEND'] },
    ruleset: { OPERATOR: '&&', SEGMENTS: ['selectors', 'block'] },
    block: { OPERATOR: '&&', SEGMENTS: ['BLOCKSTART', 'blockProperty*', 'blockPropertyNoSemi?', 'BLOCKENDSEMI'] },
    blockProperty: { OPERATOR: '||', SEGMENTS: ['blockPropertySemi', 'statement'] },
    blockPropertySemi: { OPERATOR: '&&', SEGMENTS: ['property', 'IMPORTANT?', 'SEMI+'] },
    blockPropertyNoSemi: { OPERATOR: '&&', SEGMENTS: ['property', 'IMPORTANT?', 'NOSEMI'] },
    // blockClose: { OPERATOR: '&&', SEGMENTS: ['BLOCKENDSEMI'] },
    NOSEMI: { OPERATOR: '&&', SEGMENTS: ['VAL__EMPTY'] },
    selectors: { OPERATOR: '&&', SEGMENTS: ['selectorWithCommentEnd', 'commaSelectorWithComment*'] },
    commaSelectorWithComment: { OPERATOR: '&&', SEGMENTS: ['COMMA', 'selectorWithComment'] },
    selectorWithCommentEnd: { OPERATOR: '&&', SEGMENTS: ['selector', 'comment?'] },
    selectorWithComment: { OPERATOR: '&&', SEGMENTS: ['comment?', 'selector', 'comment?'] },
    comment: { OPERATOR: '||', SEGMENTS: ['SL_COMMENT', 'COMMENT'] },
    selector: { OPERATOR: '&&', SEGMENTS: ['selectorPart*', 'selectorPrefix?', 'pseudo*'] },
    selectorPart: { OPERATOR: '||', SEGMENTS: ['selectorStartWithAttrib', 'attrib'] },
    selectorStartWithAttrib: { OPERATOR: '||', SEGMENTS: ['selectorStart', 'attrib'] },
    selectorStart: { OPERATOR: '||', SEGMENTS: ['element', 'selectorPrefixElement'] },
    selectorPrefixElement: { OPERATOR: '&&', SEGMENTS: ['selectorPrefix', 'element'] },
    selectorPrefix: { OPERATOR: '||', SEGMENTS: ['GTPrefix', 'PLUS', 'TIL', 'AND'] },
    GTPrefix: { OPERATOR: '&&', SEGMENTS: ['GT', 'GTGT?'] },
    GTGT: { OPERATOR: '&&', SEGMENTS: ['GT', 'GT'] },
    element: { OPERATOR: '||', SEGMENTS: ['identifier', 'hashIdentifier', 'dotIdentifier', 'percIdentifier', 'AND', 'TIMES', 'pseudo', 'elementInBrackets'] },
    elementInBrackets: { OPERATOR: '&&', SEGMENTS: ['LBRACK', 'element', 'RBRACK'] },
    hashIdentifier: { OPERATOR: '&&', SEGMENTS: ['HASH', 'identifier'] },
    dotIdentifier: { OPERATOR: '&&', SEGMENTS: ['DOT', 'identifier'] },
    percIdentifier: { OPERATOR: '&&', SEGMENTS: ['PERC', 'identifier'] },
    pseudo: { OPERATOR: '||', SEGMENTS: ['pseudoValueInParens', 'pseudoIdentifier', 'pseudoFunctionCall'] },
    pseudoValueInParens: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'pseudoValue', 'RPAREN'] },
    pseudoValue: { OPERATOR: '||', SEGMENTS: ['pseudo', 'attrib', 'NTH', 'NUMBER', 'ODDEVEN', 'hashBlock', 'selector'] },
    pseudoIdentifier: { OPERATOR: '&&', SEGMENTS: ['colonOrColonColon', 'IDENTIFIER'] },
    pseudoFunctionCall: { OPERATOR: '&&', SEGMENTS: ['colonOrColonColon', 'functionCall'] },
    colonOrColonColon: { OPERATOR: '||', SEGMENTS: ['COLONCOLON', 'COLON'] },
    attrib: { OPERATOR: '&&', SEGMENTS: ['LBRACK', 'IDENTIFIER', 'attribRelateStringLiteralOrIdentifier?', 'RBRACK'] },
    stringLiteralOrIdentifier: { OPERATOR: '||', SEGMENTS: ['STRINGLITERAL', 'IDENTIFIER'] },
    attribRelateStringLiteralOrIdentifier: { OPERATOR: '&&', SEGMENTS: ['attribRelate', 'stringLiteralOrIdentifier'] },
    attribRelate: { OPERATOR: '||', SEGMENTS: ['EQ', 'PIPE_EQ', 'TILD_EQ', 'STAR_EQ'] },
    identifier: { OPERATOR: '&&', SEGMENTS: ['hashBlockOrIdentifier', 'hashBlockOrIdentifierPart*'] },
    hashBlockOrIdentifierPart: { OPERATOR: '&&', SEGMENTS: ['DASH?', 'hashBlockOrIdentifier'] },
    hashBlockOrIdentifier: { OPERATOR: '||', SEGMENTS: ['hashBlock', 'IDENTIFIER', 'PATHIDENTIFIER'] },
    hashBlock: { OPERATOR: '&&', SEGMENTS: ['HASH', 'hashBlockStart', 'hashBlockExpression', 'hashBlockEnd'] },
    hashBlockExpression: { OPERATOR: '&&', SEGMENTS: ['expression+'] },
    hashBlockStart: { OPERATOR: '&&', SEGMENTS: ['BLOCKSTART'] },
    hashBlockEnd: { OPERATOR: '&&', SEGMENTS: ['BLOCKEND'] },
    // identifierVariableName: { OPERATOR: '&&', SEGMENTS: ['DOLLAR', 'IDENTIFIER'] },
    property: { OPERATOR: '&&', SEGMENTS: ['identifier', 'colonValues'] },
    // propertyInParen: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'property', 'RPAREN'] },
    values: { OPERATOR: '&&', SEGMENTS: ['commandStatement', 'commaCommandStatement*'] },
    // values3Plus: { OPERATOR: '&&', SEGMENTS: ['commandStatement', 'commandStatement', 'commandStatement', 'commaCommandStatement*'] },
    commaCommandStatement: { OPERATOR: '&&', SEGMENTS: ['COMMA', 'commandStatement'] },
    functionCall: { OPERATOR: '&&', SEGMENTS: ['IDENTIFIER', 'functionCallStart', 'functionCallArguments', 'functionCallEnd'] },
    functionCallStart: { OPERATOR: '&&', SEGMENTS: ['LPAREN'] },
    functionCallEnd: { OPERATOR: '&&', SEGMENTS: ['RPAREN'] },
    functionCallArguments: { OPERATOR: '&&', SEGMENTS: ['commandStatement'] },

    // Url
    Url: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'URL', 'RPAREN'] },

    // Key Frames
    DECLARATION_KEYFRAMES: { OPERATOR: '&&', SEGMENTS: ['VAL_KEYFRAMES', 'TYPE_KEYFRAMES_IDENTIFIER', 'BLOCKSTART', '_KEYFRAMES_ENTRY*', 'TYPE_KEYFRAMES_END'] },
    TYPE_KEYFRAMES_IDENTIFIER: { OPERATOR: '&&', SEGMENTS: ['IDENTIFIER'] },
    _KEYFRAMES_ENTRY: { OPERATOR: '&&', SEGMENTS: ['TYPE_KEYFRAMES_ENTRY_KEY', 'BLOCKSTART', 'TYPE_KEYFRAMES_ENTRY_PROPERTY', 'COLON', 'values', 'SEMI?', 'TYPE_KEYFRAMES_ENTRY_END'] },
    TYPE_KEYFRAMES_ENTRY_KEY: { OPERATOR: '||', SEGMENTS: ['VAL_MEASUREMENT', 'NUMBER'] },
    TYPE_KEYFRAMES_ENTRY_PROPERTY: { OPERATOR: '&&', SEGMENTS: ['values'] },
    TYPE_KEYFRAMES_ENTRY_END: { OPERATOR: '&&', SEGMENTS: ['BLOCKEND'] },
    TYPE_KEYFRAMES_END: { OPERATOR: '&&', SEGMENTS: ['BLOCKEND'] },

    // Conditions
    TYPE_CONDITIONS: { OPERATOR: '||', SEGMENTS: ['TYPE_CONDITION_COMBINING', 'TYPE_CONDITION_COMPARISON', 'TYPE_CONDITION_LEAF'] },
    TYPE_CONDITION_COMBINING: { OPERATOR: '&&', SEGMENTS: ['_CONDITION_COMBINING_VALUE', '_COMBINE__CONDITION_COMBINING_VALUE+'] },
    _CONDITION_COMBINING_VALUE: { OPERATOR: '||', SEGMENTS: ['TYPE_CONDITION_COMPARISON', 'TYPE_CONDITION_LEAF'] },
    _COMBINE__CONDITION_COMBINING_VALUE: { OPERATOR: '&&', SEGMENTS: ['TYPE_COMBINE_OPERATORS', '_CONDITION_COMBINING_VALUE'] },
    TYPE_CONDITION_COMPARISON: { OPERATOR: '&&', SEGMENTS: ['TYPE_CONDITION_LEAF', '_COMPARE_CONDITION_VALUE*'] },
    _COMPARE_CONDITION_VALUE: { OPERATOR: '&&', SEGMENTS: ['TYPE_COMPARE_OPERATORS', 'TYPE_CONDITION_LEAF'] },
    TYPE_CONDITION_LEAF: { OPERATOR: '||', SEGMENTS: ['_CONDITION_IN_PAREN', 'TYPE_CONDITION_VALUE'], },
    _CONDITION_IN_PAREN: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'TYPE_CONDITIONS', 'RPAREN'] },
    TYPE_CONDITION_VALUE: { OPERATOR: '||', SEGMENTS: ['NUMBER', 'variableName', 'BOOLEAN', 'STRINGLITERAL', 'IDENTIFIER'] },
    TYPE_COMPARE_OPERATORS: { OPERATOR: '||', SEGMENTS: ['EQEQ', 'LTEQ', 'LT', 'GTEQ', 'GT', 'NOTEQ'] },
    TYPE_COMBINE_OPERATORS: { OPERATOR: '||', SEGMENTS: ['COMBINE_COMPARE_AND', 'COMBINE_COMPARE_OR', 'AND_LITERAL', 'OR_LITERAL'] },

    // Other:
    BOOLEAN: { OPERATOR: '||', SEGMENTS: ['TRUE', 'FALSE'] },
    MEASUREMENT: { OPERATOR: '&&', SEGMENTS: ['VAL_MEASUREMENT'] },

    VAL_KEYFRAMES: { OPERATOR: '==', VALUE: '@keyframes' },
    VAL_MEASUREMENT: { OPERATOR: '==', VALUE: '\\-?(?:[0-9]*\\.)?[0-9]+(?:%|vh|vw|px|rem|cm|mm|in|pt|pc|em|ex|deg|rad|grad|ms|s|hz|khz)' },

    VAL__EMPTY: { OPERATOR: '==', VALUE: '' },
    NULL: { OPERATOR: '==', VALUE: 'null' },
    IN: { OPERATOR: '==', VALUE: 'in' },
    UNIT: { OPERATOR: '==', VALUE: '(%|vh|px|rem|cm|mm|in|pt|pc|em|ex|deg|rad|grad|ms|s|hz|khz)' },
    // COMBINE_COMPARE: { OPERATOR: '||', SEGMENTS: ['COMBINE_COMPARE_AND', 'COMBINE_COMPARE_OR'] },
    COMBINE_COMPARE_AND: { OPERATOR: '==', VALUE: '[&][&]' },
    COMBINE_COMPARE_OR: { OPERATOR: '==', VALUE: '[|][|]' },
    AND_LITERAL: { OPERATOR: '==', VALUE: '(?:AND|And|and)' },
    OR_LITERAL: { OPERATOR: '==', VALUE: '(?:OR|Or|or)' },
    ELLIPSIS: { OPERATOR: '==', VALUE: '\\.\\.\\.' },
    LPAREN: { OPERATOR: '==', VALUE: '\\(' },
    RPAREN: { OPERATOR: '==', VALUE: '\\)' },
    BLOCKSTART: { OPERATOR: '==', VALUE: '\\{' },
    BLOCKEND: { OPERATOR: '==', VALUE: '\\}' },
    BLOCKENDSEMI: { OPERATOR: '==', VALUE: '\\};*' },
    LBRACK: { OPERATOR: '==', VALUE: '\\[' },
    RBRACK: { OPERATOR: '==', VALUE: '\\]' },
    GT: { OPERATOR: '==', VALUE: '>' },
    GTEQ: { OPERATOR: '==', VALUE: '>=' },
    TIL: { OPERATOR: '==', VALUE: '~' },
    LT: { OPERATOR: '==', VALUE: '<' },
    LTEQ: { OPERATOR: '==', VALUE: '<=' },
    COLON: { OPERATOR: '==', VALUE: ':' },
    SEMI: { OPERATOR: '==', VALUE: ';' },
    COMMA: { OPERATOR: '==', VALUE: ',' },
    DOT: { OPERATOR: '==', VALUE: '\\.' },
    DOLLAR: { OPERATOR: '==', VALUE: '\\$' },
    AT: { OPERATOR: '==', VALUE: '@' },
    AND: { OPERATOR: '==', VALUE: '&' },
    HASH: { OPERATOR: '==', VALUE: '#' },
    DASH: { OPERATOR: '==', VALUE: '\\-' },
    COLONCOLON: { OPERATOR: '==', VALUE: '::' },
    PLUS: { OPERATOR: '==', VALUE: '\\+' },
    TIMES: { OPERATOR: '==', VALUE: '\\*' },
    DIV: { OPERATOR: '==', VALUE: '\\/' },
    MINUS: { OPERATOR: '==', VALUE: '\\-' },
    PERC: { OPERATOR: '==', VALUE: '%' },
    EQEQ: { OPERATOR: '==', VALUE: '==' },
    NOTEQ: { OPERATOR: '==', VALUE: '!=' },
    EQ: { OPERATOR: '==', VALUE: '=' },
    PIPE_EQ: { OPERATOR: '==', VALUE: '[|]=' },
    TILD_EQ: { OPERATOR: '==', VALUE: '~=' },
    STAR_EQ: { OPERATOR: '==', VALUE: '[*]=' },
    MIXIN: { OPERATOR: '==', VALUE: '@mixin' },
    FUNCTION: { OPERATOR: '==', VALUE: '@function' },
    AT_ELSE: { OPERATOR: '==', VALUE: '@else' },
    IF: { OPERATOR: '==', VALUE: 'if' },
    AT_IF: { OPERATOR: '==', VALUE: '@if' },
    AT_FOR: { OPERATOR: '==', VALUE: '@for' },
    AT_WHILE: { OPERATOR: '==', VALUE: '@while' },
    AT_EACH: { OPERATOR: '==', VALUE: '@each' },
    INCLUDE: { OPERATOR: '==', VALUE: '@include' },
    IMPORT: { OPERATOR: '==', VALUE: '@import' },
    IMPORTANT: { OPERATOR: '==', VALUE: '\\!important' },
    RETURN: { OPERATOR: '==', VALUE: '@return' },
    FONT_FACE: { OPERATOR: '==', VALUE: '@font-face' },
    MEDIA: { OPERATOR: '==', VALUE: '@media' },
    PAGE: { OPERATOR: '==', VALUE: '@page' },
    EXTEND: { OPERATOR: '==', VALUE: '@extend' },
    FROM: { OPERATOR: '==', VALUE: 'from' },
    THROUGH: { OPERATOR: '==', VALUE: 'through' },
    SCREEN: { OPERATOR: '==', VALUE: 'screen' },
    POUND_DEFAULT: { OPERATOR: '==', VALUE: '!default' },
    PATHIDENTIFIER: { OPERATOR: '==', VALUE: '\\/\\-*[a-zA-Z\\u0100-\\ufffe_][a-zA-Z\\u0100-\\ufffe0-9_-]*\\/' },
    IDENTIFIER: { OPERATOR: '==', VALUE: '\\-*[a-zA-Z\\u0100-\\ufffe_][a-zA-Z\\u0100-\\ufffe0-9_-]*' },
    STRING: { OPERATOR: '||', SEGMENTS: ['STRING_SINGLE_QUOTED', 'STRING_DOUBLE_QUOTED'] },
    STRING_SINGLE_QUOTED: { OPERATOR: '==', VALUE: '\'[^\'\\n\\r]*\'' },
    STRING_DOUBLE_QUOTED: { OPERATOR: '==', VALUE: '"[^"\\n\\r]*"' },
    STRINGLITERAL: { OPERATOR: '&&', SEGMENTS: ['STRING'] },
    TRUE: { OPERATOR: '==', VALUE: '[Tt]rue' },
    FALSE: { OPERATOR: '==', VALUE: '[Ff]alse' },
    NUMBER: { OPERATOR: '==', VALUE: '\\-?(?:[0-9]*\\.)?[0-9]+' },
    ODDEVEN: { OPERATOR: '||', SEGMENTS: ['ODD', 'EVEN'] },
    ODD: { OPERATOR: '==', VALUE: '[Oo]dd' },
    EVEN: { OPERATOR: '==', VALUE: '[Ee]ven' },
    NTH: { OPERATOR: '==', VALUE: '[0-9]n' },
    COLOR: { OPERATOR: '==', VALUE: '#[0-9a-fA-F]+' },
    RGB_NUMERIC_VAL: { OPERATOR: '==', VALUE: '(?:[0-9]{0,3}\\.)?[0-9]+' },
    SL_COMMENT: { OPERATOR: '==', VALUE: '\\/\\/[^\\n\\r]*' },
    COMMENT: { OPERATOR: '==', VALUE: '\\/\\*[\\s\\S]*?\\*\\/' },
    URL: { OPERATOR: '||', SEGMENTS: ['STRING', 'URLVAL'] },
    URLVAL: { OPERATOR: '==', VALUE: '[^\\)]+' }
},
    // Dependent On:
    [
        require('./base')
    ]);

// ******************************