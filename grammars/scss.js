'use strict'; // JS: ES5

// ******************************
//
//
// SCSS DEFINITION FILE
//
//
// ******************************

// ******************************
// Requires:
// ******************************

var grammar = require('./_core');

// ******************************
// Definition:
// ******************************

module.exports = grammar.export_grammar({
  START: { OPERATOR: '||', SEGMENTS: ['stylesheet'] },
  stylesheet: { OPERATOR: '&&', SEGMENTS: ['statement*'] },
  statement: { OPERATOR: '||', SEGMENTS: ['DECLARATION_CLASS', 'TYPE_COMMENT', 'importDeclaration', 'includeDeclaration', 'fontFaceDeclaration', 'mediaDeclaration', 'DECLARATION_KEYFRAMES', 'pageDeclaration', 'extendDeclaration', 'mixinDeclaration', 'functionDeclaration', 'variableDeclaration', 'ifDeclaration', 'forDeclaration', 'whileDeclaration', 'eachDeclaration', 'nested'] },

  DECLARATION_CLASS: { OPERATOR: '&&', SEGMENTS: ['SELECTORS', 'BLOCK'] },
  SELECTORS: { OPERATOR: '&&', SEGMENTS: ['TYPE_SELECTOR', 'COMMA_SELECTOR*'] },
  COMMA_SELECTOR: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'TYPE_SELECTOR'] },

  TYPE_SELECTOR: { OPERATOR: '&&', SEGMENTS: ['SELECTOR_PREFIX?', 'SELECTOR_ELEMENT', 'PREFIXED_SELECTOR_ELEMENT*'] },
  PREFIXED_SELECTOR_ELEMENT: { OPERATOR: '&&', SEGMENTS: ['SELECTOR_PREFIX?', 'SELECTOR_ELEMENT'] },
  SELECTOR_ELEMENT: { OPERATOR: '&&', SEGMENTS: ['SELECTOR_ELEMENT_NAME', 'SELECTOR_ELEMENT_MODIFIER?'] },
  SELECTOR_ELEMENT_MODIFIER: { OPERATOR: '&&', SEGMENTS: ['VAL__COLON', 'VAL__SELECTOR_MODIFIER'] },
  SELECTOR_ELEMENT_NAME: { OPERATOR: '||', SEGMENTS: ['DOT_SELECTOR_NAME', 'HASH_SELECTOR_NAME', 'VAL__SELECTOR_NAME'] },
  SELECTOR_PREFIX: { OPERATOR: '||', SEGMENTS: ['GT_PREFIX', 'AMP_PREFIX', 'VAL__PLUS', 'VAL__TIL'] },
  GT_PREFIX: { OPERATOR: '&&', SEGMENTS: ['VAL__GT', 'GTGT?'] },
  GTGT: { OPERATOR: '&&', SEGMENTS: ['VAL__GT', 'VAL__GT'] },
  AMP_PREFIX: { OPERATOR: '&&', SEGMENTS: ['VAL__AMP', 'AMP_PREFIX_REMAINDER'] },
  AMP_PREFIX_REMAINDER: { OPERATOR: '||', SEGMENTS: ['VAL__COLON', 'VAL__MINUS'] },

  DOT_SELECTOR_NAME: { OPERATOR: '&&', SEGMENTS: ['VAL__DOT', 'VAL__SELECTOR_NAME'] },
  HASH_SELECTOR_NAME: { OPERATOR: '&&', SEGMENTS: ['VAL__HASH', 'VAL__SELECTOR_NAME'] },

  BLOCK: { OPERATOR: '&&', SEGMENTS: ['VAL__CURLY_L', 'BLOCK_CONTENT_ENTRY*', 'BLOCK_PROPERTY_ENTRY_WITHOUT_SEMI?', 'VAL__CURLY_R'] },

  BLOCK_CONTENT_ENTRY: { OPERATOR: '||', SEGMENTS: ['BLOCK_PROPERTY_ENTRY', 'BLOCK_CLASS_ENTRY', 'TYPE_COMMENT'] },

  BLOCK_PROPERTY_ENTRY: { OPERATOR: '&&', SEGMENTS: ['DECLARATION_BLOCK_PROPERTY', 'VAL__SEMI'] },
  BLOCK_PROPERTY_ENTRY_WITHOUT_SEMI: { OPERATOR: '&&', SEGMENTS: ['DECLARATION_BLOCK_PROPERTY', 'MISSING_SEMI'] },
  MISSING_SEMI: { OPERATOR: '&&', SEGMENTS: ['VAL__EMPTY'] },

  BLOCK_CLASS_ENTRY: { OPERATOR: '&&', SEGMENTS: ['DECLARATION_CLASS'] },

  DECLARATION_BLOCK_PROPERTY: { OPERATOR: '&&', SEGMENTS: [ 'TYPE_PROPERTY_KEY', 'VAL__COLON', 'TYPE_PROPERTY_VALUE', 'IMPORTANT?'] },
  TYPE_PROPERTY_KEY: { OPERATOR: '&&', SEGMENTS: ['VAL__DOLLAR?', 'VAL__PROPERTY_KEY'] },
  TYPE_PROPERTY_VALUE: { OPERATOR: '||', SEGMENTS: ['COMMA_SEPERATED_EXPRESSION'] },
  IMPORTANT: { OPERATOR: '==', VALUE: '\\!important' },

  COMMA_SEPERATED_EXPRESSION: { OPERATOR: '&&', SEGMENTS: ['EXPRESSION', 'COMMAN_EXPRESSION*'] },
  COMMAN_EXPRESSION: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'EXPRESSION'] },

  EXPRESSION: { OPERATOR: '&&', SEGMENTS: ['EXPRESSION_PART', 'DELIM_EXPRESSION_PART*'] },
  DELIM_EXPRESSION_PART: { OPERATOR: '&&', SEGMENTS: ['EXPRESSION_PART_DELIM?', 'EXPRESSION_PART'] },
  EXPRESSION_PART_DELIM: { OPERATOR: '||', SEGMENTS: ['MATH_CHARACTER', 'VAL__SPACE'] },
  EXPRESSION_PART: { OPERATOR: '&&', SEGMENTS: ['VAL__NEGATE?', 'EXPRESSION_PART_REMAINDER'] },
  EXPRESSION_PART_REMAINDER: { OPERATOR: '||', SEGMENTS: ['TYPE_HASH_EXPRESSION', 'TYPE_KEYWORD_EXPRESSION', 'TYPE_COLOUR_EXPRESSION', 'TYPE_STRING_EXPRESSION', 'TYPE_VARIABLE_EXPRESSION', 'TYPE_NUMERIC_EXPRESSION', 'TYPE_PAREN_EXPRESSION'] },

  TYPE_PAREN_EXPRESSION: { OPERATOR: '&&', SEGMENTS: ['VAL__PAREN_L', 'EXPRESSION', 'VAL__PAREN_R'] },
  TYPE_NUMERIC_EXPRESSION: { OPERATOR: '&&', SEGMENTS: ['VAL__NUMBER', 'VAL__UNIT?'] },
  TYPE_STRING_EXPRESSION: { OPERATOR: '&&', SEGMENTS: ['STRING'] },
  TYPE_COLOUR_EXPRESSION: { OPERATOR: '&&', SEGMENTS: ['VAL__HEX_COLOUR'] },
  TYPE_KEYWORD_EXPRESSION: { OPERATOR: '&&', SEGMENTS: ['VAL__KEYWORD_NAME', 'TYPE_FUNCTION_CALL?'] },
  TYPE_VARIABLE_EXPRESSION: { OPERATOR: '&&', SEGMENTS: ['VAL__DOLLAR', 'VAL__VARIABLE_NAME'] },
  TYPE_HASH_EXPRESSION: { OPERATOR: '&&', SEGMENTS: ['VAL__HASH', 'VAL__CURLY_L', 'EXPRESSION', 'VAL__CURLY_R'] },

  TYPE_FUNCTION_CALL: { OPERATOR: '&&', SEGMENTS: ['VAL__PAREN_L', 'FUNCTION_PARAMS?', 'VAL__PAREN_R'] },
  FUNCTION_PARAMS: { OPERATOR: '&&', SEGMENTS: ['FUNCTION_PARAM', 'COMMA_FUNCTION_PARAM*'] },
  COMMA_FUNCTION_PARAM: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'FUNCTION_PARAM'] },
  FUNCTION_PARAM: { OPERATOR: '&&', SEGMENTS: ['EXPRESSION'] },

  MATH_CHARACTER: { OPERATOR: '||', SEGMENTS: ['VAL__TIMES', 'VAL__PLUS', 'VAL__DIVIDE', 'MINUS_SPACE', 'VAL__PERC'] },
  MINUS_SPACE: { OPERATOR: '&&', SEGMENTS: ['VAL__MINUS', 'VAL__SPACE'] },

  TYPE_COMMENT: { OPERATOR: '||', SEGMENTS: ['VAL__MULTI_LINE_COMMENT', 'VAL__SINGLE_LINE_COMMENT'] },

  STRING: { OPERATOR: '||', SEGMENTS: ['VAL__STRING_SINGLE_QUOTED', 'VAL__STRING_DOUBLE_QUOTED'] },

  VAL__NEGATE: { OPERATOR: '==', VALUE: '[-]' },
  VAL__UNIT: { OPERATOR: '==', VALUE: '(%|vh|px|rem|cm|mm|in|pt|pc|em|ex|deg|rad|grad|ms|s|hz|khz)' },
  VAL__STRING_SINGLE_QUOTED: { OPERATOR: '==', VALUE: '\'[^\'\\n\\r]*\'' },
  VAL__STRING_DOUBLE_QUOTED: { OPERATOR: '==', VALUE: '"[^"\\n\\r]*"' },
  VAL__NUMBER: { OPERATOR: '==', VALUE: '\\-?(?:[0-9]*\\.)?[0-9]+' },
  VAL__MULTI_LINE_COMMENT: { OPERATOR: '==', VALUE: '\/\\*[\\s\\S]*?\\*\/' },
  VAL__SINGLE_LINE_COMMENT: { OPERATOR: '==', VALUE: '\\/\\/[^\\n\\r]*' },
  VAL__PROPERTY_KEY: { OPERATOR: '==', VALUE: '\\-*[a-zA-Z\\u0100-\\ufffe_][a-zA-Z\\u0100-\\ufffe0-9_-]*' },
  VAL__SELECTOR_NAME: { OPERATOR: '==', VALUE: '\\-*[a-zA-Z\\u0100-\\ufffe_][a-zA-Z\\u0100-\\ufffe0-9_-]*' },
  VAL__SELECTOR_MODIFIER: { OPERATOR: '==', VALUE: '\\-*[a-zA-Z\\u0100-\\ufffe_][a-zA-Z\\u0100-\\ufffe0-9_-]*' },
  VAL__VARIABLE_NAME: { OPERATOR: '==', VALUE: '\\-*[a-zA-Z\\u0100-\\ufffe_][a-zA-Z\\u0100-\\ufffe0-9_-]*' },
  VAL__KEYWORD_NAME: { OPERATOR: '==', VALUE: '\\-*[a-zA-Z\\u0100-\\ufffe_][a-zA-Z\\u0100-\\ufffe0-9_-]*' },
  VAL__HEX_COLOUR: { OPERATOR: '==', VALUE: '#[0-9a-fA-F]+' },




  params: { OPERATOR: '&&', SEGMENTS: ['param', 'paramMore*', 'Ellipsis?'] },
  paramMore: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'param*', 'Ellipsis?'] },
  param: { OPERATOR: '&&', SEGMENTS: ['variableName', 'paramOptionalValue?'] },
  variableName: { OPERATOR: '&&', SEGMENTS: ['DOLLAR', 'Identifier?'] },
  paramOptionalValue: { OPERATOR: '&&', SEGMENTS: ['COLON', 'expression'] },
  paramsInParen: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'params?', 'RPAREN'] },
  valuesInParen: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'values?', 'RPAREN'] },
  mixinDeclaration: { OPERATOR: '&&', SEGMENTS: ['MIXIN', 'Identifier', 'paramsInParen?', 'block'] },
  pageDeclaration: { OPERATOR: '&&', SEGMENTS: ['PAGE', 'block'] },
  extendDeclaration: { OPERATOR: '&&', SEGMENTS: ['EXTEND', 'percIdentifier', 'VAL__SEMI?'] },
  includeDeclaration: { OPERATOR: '&&', SEGMENTS: ['INCLUDE', 'Identifier', 'includeDeclarationTermination'] },
  includeDeclarationTermination: { OPERATOR: '||', SEGMENTS: ['VAL__SEMI+', 'valuesInParenSemiBlock'] },
  fontFaceDeclaration: { OPERATOR: '&&', SEGMENTS: ['FONT_FACE', 'fontFaceDeclarationStart', 'fontFaceDeclarationValues', 'fontFaceDeclarationEnd'] },
  fontFaceDeclarationStart: { OPERATOR: '&&', SEGMENTS: ['BlockStart'] },
  fontFaceDeclarationValues: { OPERATOR: '&&', SEGMENTS: ['blockProperty*'] },
  fontFaceDeclarationEnd: { OPERATOR: '&&', SEGMENTS: ['BlockEnd'] },
  mediaDeclaration: { OPERATOR: '&&', SEGMENTS: ['MEDIA', 'mediaDeclarationParts', 'mediaDeclarationTermination'] },
  mediaDeclarationParts: { OPERATOR: '&&', SEGMENTS: ['mediaDeclarationPart+', 'commaMediaDeclarationPart*'] },
  commaMediaDeclarationPart: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'mediaDeclarationPart*'] },
  mediaDeclarationPart: { OPERATOR: '||', SEGMENTS: ['propertyInParen', 'identifier'] },
  mediaDeclarationTermination: { OPERATOR: '||', SEGMENTS: ['VAL__SEMI+', 'valuesInParenSemiBlock'] },
  valuesInParenSemi: { OPERATOR: '&&', SEGMENTS: ['valuesInParen', 'VAL__SEMI?'] },
  valuesInParenSemiBlock: { OPERATOR: '&&', SEGMENTS: ['valuesInParenSemi?', 'block?'] },
  functionDeclaration: { OPERATOR: '&&', SEGMENTS: ['FUNCTION', 'Identifier', 'paramsInParen', 'BlockStart', 'functionBody?', 'BlockEnd'] },
  functionBody: { OPERATOR: '&&', SEGMENTS: ['functionStatement*', 'functionReturn'] },
  functionReturn: { OPERATOR: '&&', SEGMENTS: ['RETURN', 'commandStatement', 'VAL__SEMI+'] },
  functionStatement: { OPERATOR: '&&', SEGMENTS: ['commandStatement', 'semiOrStatement'] },
  semiOrStatement: { OPERATOR: '||', SEGMENTS: ['VAL__SEMI+', 'statement'] },
  commandStatement: { OPERATOR: '&&', SEGMENTS: ['expressionOrCommandStatement', 'mathStatement?'] },
  expressionOrCommandStatement: { OPERATOR: '||', SEGMENTS: ['expressions', 'commaCommandStatement'] },
  expressions: { OPERATOR: '&&', SEGMENTS: ['expression+', 'commaExpression*', 'extraComma?'] },
  commaExpression: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'expression+'] },
  mathCharacter: { OPERATOR: '||', SEGMENTS: ['TIMES', 'PLUS', 'DIV', 'MINUS', 'PERC'] },
  mathStatement: { OPERATOR: '&&', SEGMENTS: ['mathCharacter', 'commandStatement'] },
  expression: { OPERATOR: '||', SEGMENTS: ['url', 'functionCall', 'mapExpression', 'TYPE_COMMENT', 'mathCharacter', 'MEASUREMENT', 'VAL__NUMBER', 'identifier', 'Color', 'StringLiteral', 'NULL', 'variableName'] },
  mapExpression: { OPERATOR: '&&', SEGMENTS: ['mapExpressionStart', 'mapEntry', 'commaMapEntry*', 'extraComma?', 'TYPE_COMMENT?', 'mapExpressionEnd'] },
  mapExpressionStart: { OPERATOR: '&&', SEGMENTS: ['LPAREN'] },
  mapExpressionEnd: { OPERATOR: '&&', SEGMENTS: ['RPAREN'] },
  mapEntry: { OPERATOR: '&&', SEGMENTS: ['TYPE_COMMENT?', 'mapEntryKeyValue', 'TYPE_COMMENT?'] },
  mapEntryKeyValue: { OPERATOR: '&&', SEGMENTS: ['mapEntryKey', 'COLON', 'mapEntryValues'] },
  mapEntryKey: { OPERATOR: '||', SEGMENTS: ['VAL__NUMBER', 'StringLiteral', 'Identifier'] },
  mapEntryValues: { OPERATOR: '&&', SEGMENTS: ['mathCharacter?', 'expression'] },
  extraComma: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA'] },
  commaMapEntry: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'mapEntry'] },
  // RGB: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'RGB_VAL', 'COMMA_RGB_VAL*', 'RPAREN'] },
  // COMMA_RGB_VAL: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'RGB_VAL'] },
  // RGB_VAL: { OPERATOR: '||', SEGMENTS: ['RGB_NUMERIC_VAL', 'variableName'] },
  ifDeclaration: { OPERATOR: '&&', SEGMENTS: ['AT_IF', 'TYPE_CONDITIONS', 'block', 'elseIfStatement*', 'elseStatement?'] },
  elseIfStatement: { OPERATOR: '&&', SEGMENTS: ['AT_ELSE', 'IF', 'TYPE_CONDITIONS', 'block'] },
  elseStatement: { OPERATOR: '&&', SEGMENTS: ['AT_ELSE', 'block'] },

  variableDeclaration: { OPERATOR: '&&', SEGMENTS: ['variableDeclarationKey', 'COLON', 'variableDeclarationValues', 'POUND_DEFAULT?', 'VAL__SEMI+'] },
  variableDeclarationKey: { OPERATOR: '||', SEGMENTS: ['StringLiteral', 'variableName'] },
  variableDeclarationValues: { OPERATOR: '&&', SEGMENTS: ['values'] },
  commaVariableName: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'variableName'] },
  commaIdentifier: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'Identifier'] },
  colonValues: { OPERATOR: '&&', SEGMENTS: ['COLON', 'values'] },
  forDeclaration: { OPERATOR: '&&', SEGMENTS: ['AT_FOR', 'variableName', 'FROM', 'fromNumber', 'THROUGH', 'through', 'block'] },
  fromNumber: { OPERATOR: '&&', SEGMENTS: ['VAL__NUMBER'] },
  through: { OPERATOR: '||', SEGMENTS: ['VAL__NUMBER', 'functionCall', 'variableName'] },
  whileDeclaration: { OPERATOR: '&&', SEGMENTS: ['AT_WHILE', 'TYPE_CONDITIONS', 'block'] },
  eachDeclaration: { OPERATOR: '&&', SEGMENTS: ['AT_EACH', 'variableName', 'commaVariableName*', 'IN', 'eachValueList', 'block'] },
  eachValueList: { OPERATOR: '&&', SEGMENTS: ['eachValueListEntry', 'commaEachValueListEntry*'] },
  eachValueListEntry: { OPERATOR: '||', SEGMENTS: ['eachValueListInParen', 'functionCall', 'identifierValue', 'variableName'] },
  commaEachValueListEntry: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'eachValueListEntry'] },
  eachValueListInParen: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'eachValueList', 'RPAREN'] },
  identifierValue: { OPERATOR: '&&', SEGMENTS: ['identifier', 'colonValues?'] },
  importDeclaration: { OPERATOR: '&&', SEGMENTS: ['IMPORT', 'referenceUrl', 'commaReferenceUrl*', 'mediaTypes?', 'VAL__SEMI+'] },
  referenceUrl: { OPERATOR: '||', SEGMENTS: ['StringLiteral', 'url'] },
  commaReferenceUrl: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'referenceUrl'] },
  mediaTypes: { OPERATOR: '&&', SEGMENTS: ['Identifier', 'commaIdentifier*'] },
  nested: { OPERATOR: '&&', SEGMENTS: ['AT', 'AND?', 'Identifier+', 'pseudo*', 'selectors', 'BlockStart', 'stylesheet', 'BlockEnd'] },
  // ruleset: { OPERATOR: '&&', SEGMENTS: ['selectors', 'block'] },
  block: { OPERATOR: '&&', SEGMENTS: ['BlockStart', 'blockProperty*', 'blockPropertyNoSemi?', 'BlockEnd'] },
  blockProperty: { OPERATOR: '||', SEGMENTS: ['blockPropertySemi'] },
  blockPropertySemi: { OPERATOR: '&&', SEGMENTS: ['property', 'IMPORTANT?', 'VAL__SEMI+'] },
  blockPropertyNoSemi: { OPERATOR: '&&', SEGMENTS: ['property', 'IMPORTANT?', 'MISSING_SEMI'] },
  // selectors: { OPERATOR: '&&', SEGMENTS: ['selector', 'commaSelector*'] },
  // commaSelector: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'selector'] },
  // selector: { OPERATOR: '&&', SEGMENTS: ['selectorStart*', 'attrib*', 'selectorPrefix?', 'pseudo*'] },
  // selectorStart: { OPERATOR: '||', SEGMENTS: ['element', 'selectorPrefixElement'] },
  // selectorPrefixElement: { OPERATOR: '&&', SEGMENTS: ['selectorPrefix', 'element'] },
  // selectorPrefix: { OPERATOR: '||', SEGMENTS: ['GTPrefix', 'PLUS', 'TIL'] },
  // GTPrefix: { OPERATOR: '&&', SEGMENTS: ['GT', 'GTGT?'] },
  // GTGT: { OPERATOR: '&&', SEGMENTS: ['GT', 'GT'] },
  element: { OPERATOR: '||', SEGMENTS: ['hashIdentifier', 'dotIdentifier', 'percIdentifier', 'AND', 'TIMES', 'pseudo', 'elementInBrackets'] },
  elementInBrackets: { OPERATOR: '&&', SEGMENTS: ['LBRACK', 'element', 'RBRACK'] },
  hashIdentifier: { OPERATOR: '&&', SEGMENTS: ['HASH', 'identifier'] },
  dotIdentifier: { OPERATOR: '&&', SEGMENTS: ['VAL__DOT', 'identifier'] },
  percIdentifier: { OPERATOR: '&&', SEGMENTS: ['PERC', 'identifier'] },
  pseudo: { OPERATOR: '||', SEGMENTS: ['pseudoValueInParens', 'pseudoFunctionCall'] },
  pseudoValueInParens: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'pseudoValue', 'RPAREN'] },
  pseudoValue: { OPERATOR: '||', SEGMENTS: ['pseudo', 'attrib', 'VAL__NUMBER', 'hashBlock'] },
  // pseudoIdentifier: { OPERATOR: '&&', SEGMENTS: ['colonOrColonColon', 'Identifier'] },
  pseudoFunctionCall: { OPERATOR: '&&', SEGMENTS: ['colonOrColonColon', 'functionCall'] },
  colonOrColonColon: { OPERATOR: '||', SEGMENTS: ['COLONCOLON', 'COLON'] },
  attrib: { OPERATOR: '&&', SEGMENTS: ['LBRACK', 'Identifier', 'attribRelateStringLiteralOrIdentifier?', 'RBRACK'] },
  stringLiteralOrIdentifier: { OPERATOR: '||', SEGMENTS: ['StringLiteral', 'Identifier'] },
  attribRelateStringLiteralOrIdentifier: { OPERATOR: '&&', SEGMENTS: ['attribRelate', 'stringLiteralOrIdentifier'] },
  attribRelate: { OPERATOR: '||', SEGMENTS: ['EQ', 'PIPE_EQ', 'TILD_EQ', 'STAR_EQ'] },
  identifier: { OPERATOR: '&&', SEGMENTS: ['hashBlockOrIdentifier', 'hashBlockOrIdentifierPart*'] },
  hashBlockOrIdentifierPart: { OPERATOR: '&&', SEGMENTS: ['DASH?', 'hashBlockOrIdentifier'] },
  hashBlockOrIdentifier: { OPERATOR: '||', SEGMENTS: ['hashBlock'] },
  hashBlock: { OPERATOR: '&&', SEGMENTS: ['HASH', 'hashBlockStart', 'hashBlockExpression', 'hashBlockEnd'] },
  hashBlockExpression: { OPERATOR: '&&', SEGMENTS: ['expression+'] },
  hashBlockStart: { OPERATOR: '&&', SEGMENTS: ['BlockStart'] },
  hashBlockEnd: { OPERATOR: '&&', SEGMENTS: ['BlockEnd'] },
  property: { OPERATOR: '&&', SEGMENTS: ['identifier', 'colonValues'] },
  propertyInParen: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'property', 'RPAREN'] },
  values: { OPERATOR: '&&', SEGMENTS: ['commandStatement', 'commaCommandStatement*'] },
  commaCommandStatement: { OPERATOR: '&&', SEGMENTS: ['VAL__COMMA', 'commandStatement'] },
  url: { OPERATOR: '&&', SEGMENTS: ['UrlStart', 'Url', 'UrlEnd'] },
  functionCall: { OPERATOR: '&&', SEGMENTS: ['Identifier', 'functionCallStart', 'functionCallArguments', 'functionCallEnd'] },
  functionCallStart: { OPERATOR: '&&', SEGMENTS: ['LPAREN'] },
  functionCallEnd: { OPERATOR: '&&', SEGMENTS: ['RPAREN'] },
  functionCallArguments: { OPERATOR: '&&', SEGMENTS: ['commandStatement'] },

  // Key Frames
  DECLARATION_KEYFRAMES: { OPERATOR: '&&', SEGMENTS: ['VAL_KEYFRAMES', 'TYPE_KEYFRAMES_IDENTIFIER', 'BlockStart', '_KEYFRAMES_ENTRY*', 'TYPE_KEYFRAMES_END'] },
  TYPE_KEYFRAMES_IDENTIFIER: { OPERATOR: '&&', SEGMENTS: ['Identifier'] },
  _KEYFRAMES_ENTRY: { OPERATOR: '&&', SEGMENTS: ['TYPE_KEYFRAMES_ENTRY_KEY', 'BlockStart', 'TYPE_KEYFRAMES_ENTRY_PROPERTY', 'COLON', 'values', 'VAL__SEMI?', 'TYPE_KEYFRAMES_ENTRY_END'] },
  TYPE_KEYFRAMES_ENTRY_KEY: { OPERATOR: '||', SEGMENTS: ['VAL_MEASUREMENT', 'VAL__NUMBER'] },
  TYPE_KEYFRAMES_ENTRY_PROPERTY: { OPERATOR: '&&', SEGMENTS: ['values'] },
  TYPE_KEYFRAMES_ENTRY_END: { OPERATOR: '&&', SEGMENTS: ['BlockEnd'] },
  TYPE_KEYFRAMES_END: { OPERATOR: '&&', SEGMENTS: ['BlockEnd'] },

  // Conditions
  TYPE_CONDITIONS: { OPERATOR: '||', SEGMENTS: ['TYPE_CONDITION_COMBINING'] },
  TYPE_CONDITION_COMBINING: { OPERATOR: '&&', SEGMENTS: ['_CONDITION_COMBINING_VALUE', '_COMBINE__CONDITION_COMBINING_VALUE+'] },
  _CONDITION_COMBINING_VALUE: { OPERATOR: '||', SEGMENTS: ['TYPE_CONDITION_COMPARISON'] },
  _COMBINE__CONDITION_COMBINING_VALUE: { OPERATOR: '&&', SEGMENTS: ['TYPE_COMBINE_OPERATORS', '_CONDITION_COMBINING_VALUE'] },
  TYPE_CONDITION_COMPARISON: { OPERATOR: '&&', SEGMENTS: ['TYPE_CONDITION_LEAF', '_COMPARE_CONDITION_VALUE*'] },
  _COMPARE_CONDITION_VALUE: { OPERATOR: '&&', SEGMENTS: ['TYPE_COMPARE_OPERATORS', 'TYPE_CONDITION_LEAF'] },
  TYPE_CONDITION_LEAF: { OPERATOR: '||', SEGMENTS: ['_CONDITION_IN_PAREN', 'TYPE_CONDITION_VALUE'], },
  _CONDITION_IN_PAREN: { OPERATOR: '&&', SEGMENTS: ['LPAREN', 'TYPE_CONDITIONS', 'RPAREN'] },
  TYPE_CONDITION_VALUE: { OPERATOR: '||', SEGMENTS: ['VAL__NUMBER', 'variableName', 'BOOLEAN', 'StringLiteral', 'Identifier'] },
  TYPE_COMPARE_OPERATORS: { OPERATOR: '||', SEGMENTS: ['EQEQ', 'LTEQ', 'LT', 'GTEQ', 'GT', 'NOTEQ'] },
  TYPE_COMBINE_OPERATORS: { OPERATOR: '||', SEGMENTS: ['COMBINE_COMPARE_AND', 'COMBINE_COMPARE_OR', 'AND_LITERAL', 'OR_LITERAL'] },

  // Other:
  BOOLEAN: { OPERATOR: '||', SEGMENTS: ['True', 'False'] },
  MEASUREMENT: { OPERATOR: '&&', SEGMENTS: ['VAL_MEASUREMENT'] },

  VAL_KEYFRAMES: { OPERATOR: '==', VALUE: '@keyframes' },
  VAL_MEASUREMENT: { OPERATOR: '==', VALUE: '\\-?(?:[0-9]*\\.)?[0-9]+(?:%|vh|px|rem|cm|mm|in|pt|pc|em|ex|deg|rad|grad|ms|s|hz|khz)' },

  NULL: { OPERATOR: '==', VALUE: 'null' },
  IN: { OPERATOR: '==', VALUE: 'in' },
  COMBINE_COMPARE_AND: { OPERATOR: '==', VALUE: '[&][&]' },
  COMBINE_COMPARE_OR: { OPERATOR: '==', VALUE: '[|][|]' },
  AND_LITERAL: { OPERATOR: '==', VALUE: '(?:AND|and)' },
  OR_LITERAL: { OPERATOR: '==', VALUE: '(?:OR|or)' },
  Ellipsis: { OPERATOR: '==', VALUE: '\\.\\.\\.' },
  LPAREN: { OPERATOR: '==', VALUE: '\\(' },
  RPAREN: { OPERATOR: '==', VALUE: '\\)' },
  BlockStart: { OPERATOR: '==', VALUE: '\\{' },
  BlockEnd: { OPERATOR: '==', VALUE: '\\}' },
  LBRACK: { OPERATOR: '==', VALUE: '\\[' },
  RBRACK: { OPERATOR: '==', VALUE: '\\]' },
  GT: { OPERATOR: '==', VALUE: '>' },
  GTEQ: { OPERATOR: '==', VALUE: '>=' },
  TIL: { OPERATOR: '==', VALUE: '~' },
  LT: { OPERATOR: '==', VALUE: '<' },
  LTEQ: { OPERATOR: '==', VALUE: '<=' },
  COLON: { OPERATOR: '==', VALUE: ':' },
  SEMI: { OPERATOR: '==', VALUE: ';' },
  COMMA: { OPERATOR: '==', VALUE: ',' },
  DOT: { OPERATOR: '==', VALUE: '\\.' },
  DOLLAR: { OPERATOR: '==', VALUE: '\\$' },
  AT: { OPERATOR: '==', VALUE: '@' },
  AND: { OPERATOR: '==', VALUE: '&' },
  HASH: { OPERATOR: '==', VALUE: '#' },
  DASH: { OPERATOR: '==', VALUE: '\\-' },
  COLONCOLON: { OPERATOR: '==', VALUE: '::' },
  PLUS: { OPERATOR: '==', VALUE: '\\+' },
  TIMES: { OPERATOR: '==', VALUE: '\\*' },
  DIV: { OPERATOR: '==', VALUE: '\\/' },
  MINUS: { OPERATOR: '==', VALUE: '\\-' },
  PERC: { OPERATOR: '==', VALUE: '%' },
  UrlStart: { OPERATOR: '&&', SEGMENTS: ['UrlStartVal', 'LPAREN'] },
  UrlStartVal: { OPERATOR: '==', VALUE: 'url' },
  EQEQ: { OPERATOR: '==', VALUE: '==' },
  NOTEQ: { OPERATOR: '==', VALUE: '!=' },
  EQ: { OPERATOR: '==', VALUE: '=' },
  PIPE_EQ: { OPERATOR: '==', VALUE: '[|]=' },
  TILD_EQ: { OPERATOR: '==', VALUE: '~=' },
  STAR_EQ: { OPERATOR: '==', VALUE: '[*]=' },
  MIXIN: { OPERATOR: '==', VALUE: '@mixin' },
  FUNCTION: { OPERATOR: '==', VALUE: '@function' },
  AT_ELSE: { OPERATOR: '==', VALUE: '@else' },
  IF: { OPERATOR: '==', VALUE: 'if' },
  AT_IF: { OPERATOR: '==', VALUE: '@if' },
  AT_FOR: { OPERATOR: '==', VALUE: '@for' },
  AT_WHILE: { OPERATOR: '==', VALUE: '@while' },
  AT_EACH: { OPERATOR: '==', VALUE: '@each' },
  INCLUDE: { OPERATOR: '==', VALUE: '@include' },
  IMPORT: { OPERATOR: '==', VALUE: '@import' },
  RETURN: { OPERATOR: '==', VALUE: '@return' },
  FONT_FACE: { OPERATOR: '==', VALUE: '@font-face' },
  MEDIA: { OPERATOR: '==', VALUE: '@media' },
  PAGE: { OPERATOR: '==', VALUE: '@page' },
  EXTEND: { OPERATOR: '==', VALUE: '@extend' },
  FROM: { OPERATOR: '==', VALUE: 'from' },
  THROUGH: { OPERATOR: '==', VALUE: 'through' },
  POUND_DEFAULT: { OPERATOR: '==', VALUE: '!default' },
  Identifier: { OPERATOR: '==', VALUE: '\\-*[a-zA-Z\\u0100-\\ufffe_][a-zA-Z\\u0100-\\ufffe0-9_-]*' },
  StringLiteral: { OPERATOR: '&&', SEGMENTS: ['STRING'] },
  True: { OPERATOR: '==', VALUE: '[T]rue' },
  False: { OPERATOR: '==', VALUE: '[Ff]alse' },
  Color: { OPERATOR: '==', VALUE: '#[0-9a-fA-F]+' },
  RGB_NUMERIC_VAL: { OPERATOR: '==', VALUE: '(?:[0-9]{0,3}\\.)?[0-9]+' },
  UrlEnd: { OPERATOR: '&&', SEGMENTS: ['RPAREN'] },
  Url: { OPERATOR: '||', SEGMENTS: ['STRING', 'UrlVal'] },
  UrlVal: { OPERATOR: '==', VALUE: '[^\)]+' }
},
// Dependant On:
[
  require('./base'),
  require('./scss')
]);

// ******************************